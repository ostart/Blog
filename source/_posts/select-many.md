---
title: LINQ оператор SelectMany
date: 2022-03-22 09:14:08
tags: [C#, SelectMany]
---

В LINQ есть такой необычный оператор, как ```SelectMany```. В чем же его необычность?

Рассмотрим сигнатуру метода:

``` csharp
IEnumerable<R> SelectMany(this IEnumerable<T> items, Func<T, IEnumerable<R>> f)
```

Из сигнатуры метода ```SelectMany``` видно, что он применяется к последовательности типа ```IEnumerable<T>```. К каждому элементу этой последовательности применяется функция ```Func<T, IEnumerable<R>>```, которая преобразует элемент типа ```T``` в последовательность типа ```IEnumerable<R>```. И на выходе мы имеем последовательность типа ```IEnumerable<R>```. Получается, что каждый элемент превращается в множество, которое может быть закрыто отличным типом от исходного, которое затем спрямляется. Результатом работы ```SelectMany``` является конкатенация всех полученных последовательностей, т.е. мы имеем не последовательность последовательностей, а единую последовательность типа, отличного от исходного (не обязательно отличного, можно получить и последовательность того же типа).

Поясним вышесказанное следующим примером:

``` csharp
string[] words = {"ab", "", "c", "de"};
IEnumerable<char> letters = words.SelectMany(w => w.ToCharArray());
Assert.That(letters, Is.EqualTo(new[] {'a', 'b', 'c', 'd', 'e'}));
```

Впрочем строка уже сама по себе является последовательностью символов и реализует интерфейс IEnumerable<char>, поэтому вызов ToCharArray на самом деле лишний.

Одно из не совсем очевидных применений ```SelectMany``` — это вычисление декартова произведения двух множеств. Декартово произведение множества {-1, 0, 1} на само себя даст все возможные относительные координаты соседей условной точки Point, где Point -- класс, имеющий координаты X и Y в качестве открытых полей. Для вычисления декартова произведения двух множеств также потребуется использовать метод ```Select``` внутри ```SelectMany```, как показано в примере ниже:

``` csharp
public static IEnumerable<Point> GetNeighbours(Point p)
{
    int[] d = {-1, 0, 1};
    return d.SelectMany(i => d.Select(s => new Point(p.X + i, p.Y + s)));
}
```